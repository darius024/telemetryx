#!/usr/bin/env python3
"""Generate Python code from Protocol Buffer definitions.

This script:
1. Compiles .proto files to Python using grpc_tools.protoc
2. Fixes import paths to work with the telemetryx package structure

Run from the python/ directory.
"""

import re
import subprocess
import sys
from pathlib import Path

# Output directory for generated Python code
OUTPUT_DIR = Path("telemetryx/proto")

# Proto directory - set dynamically in main()
PROTO_DIR: Path = Path(".")

# Proto files to compile
PROTO_FILES = [
    "common.proto",
    "rules.proto",
    "analytics.proto",
]


def run_protoc() -> None:
    """Run the protobuf compiler to generate Python code."""
    print("Compiling Protocol Buffers...")

    # Ensure output directory exists
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

    # Build the protoc command
    proto_paths = [str(PROTO_DIR / f) for f in PROTO_FILES]

    cmd = [
        sys.executable,
        "-m",
        "grpc_tools.protoc",
        f"-I{PROTO_DIR}",
        f"--python_out={OUTPUT_DIR}",
        f"--grpc_python_out={OUTPUT_DIR}",
        *proto_paths,
    ]

    print(f"  Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        print(f"protoc failed:\n{result.stderr}")
        sys.exit(1)

    print("âœ… Proto compilation complete")


def fix_imports() -> None:
    """Fix import statements in generated files.

    The protoc compiler generates imports like:
        import common_pb2 as common__pb2

    We need to change them to:
        from telemetryx.proto import common_pb2 as common__pb2
    """
    print("Fixing import paths...")

    # Patterns to fix
    # Match: import <name>_pb2 as <alias>
    import_pattern = re.compile(r"^import (\w+_pb2) as (\w+)$", re.MULTILINE)

    # Replacement: from telemetryx.proto import <name>_pb2 as <alias>
    def replacement(match: re.Match) -> str:
        module = match.group(1)
        alias = match.group(2)
        return f"from telemetryx.proto import {module} as {alias}"

    # Process all generated files
    for py_file in OUTPUT_DIR.glob("*_pb2*.py"):
        content = py_file.read_text()
        original = content

        # Apply fix
        content = import_pattern.sub(replacement, content)

        if content != original:
            py_file.write_text(content)
            print(f"  Fixed: {py_file.name}")
        else:
            print(f"  Skipped (no changes): {py_file.name}")

    print("Import fixes complete")


def create_init_file() -> None:
    """Create/update __init__.py for the proto package."""
    print("Creating __init__.py...")

    init_content = '''"""Generated Protocol Buffer code.

Auto-generated by scripts/generate_proto.py - do not edit manually.
"""
'''

    init_file = OUTPUT_DIR / "__init__.py"
    init_file.write_text(init_content)
    print(f"  Created: {init_file}")


def find_proto_dir() -> Path:
    """Find the proto directory, checking multiple locations."""
    candidates = [
        Path("../proto"),  # Local: running from python/
        Path("proto"),  # Docker: proto copied to working dir
    ]
    for candidate in candidates:
        if candidate.exists() and (candidate / "common.proto").exists():
            return candidate
    return Path(".")  # Fallback, will fail later with clear error


def main() -> None:
    """Main entry point."""
    global PROTO_DIR

    print("=" * 60)
    print("TelemetryX Proto Generator")
    print("=" * 60)
    print()

    # Find proto directory
    PROTO_DIR = find_proto_dir()

    # Check proto files exist
    if not (PROTO_DIR / "common.proto").exists():
        print("Error: Proto files not found.")
        print("  Checked: ../proto/, proto/")
        print("  Run from python/ directory or ensure proto files are present.")
        sys.exit(1)

    print(f"Using proto directory: {PROTO_DIR}")

    # Run steps
    run_protoc()
    fix_imports()
    create_init_file()

    print()
    print("=" * 60)
    print("All done! Generated files in:", OUTPUT_DIR)
    print("=" * 60)


if __name__ == "__main__":
    main()
