//! TelemetryX Common - Shared domain types and utilities
//!
//! This crate holds ergonomic, application-level types that represent events as
//! the ingestion service and other components expect to consume and process.
//!
//! Design goals and reasoning:
//! - Keep a clear separation between "wire format" (the Protobuf messages
//!   generated by prost/tonic) and domain types (Rust-native types used in the
//!   application). This separation makes business logic easier to write and
//!   reason about and keeps generated code isolated.
//! - Provide friendly serialization (via serde) for JSON-based endpoints and
//!   logging, while still supporting efficient binary payloads.
//! - Provide small, well-documented helpers for common operations (validation,
//!   conversions, etc.).
//!
//! Notes on Protobuf interoperability:
//! - When we add `proto/events.proto`, prost will generate Rust types that map
//!   1:1 to the wire format. We'll implement `TryFrom<proto::Event>` ->
//!   `telemetryx_common::types::Event` (and optionally the reverse) to convert
//!   between the wire and domain representations. Timestamp conversion should
//!   use `prost_types::Timestamp` <-> `chrono::DateTime<Utc>` conversion helpers.
//! - Keep proto messages minimal and use `reserved` when removing fields to
//!   avoid accidental reuse of field numbers.
//!
//! Security & operational notes:
//! - Binary payloads can be large and may contain arbitrary bytes. Treat them
//!   as opaque by default (do not attempt to parse unless you trust the
//!   producer or validate the schema). Consider size limits and rate limiting
//!   at the ingestion boundary.
//! - JSON payloads are parsed into `serde_json::Value`. If you expect a
//!   specific schema, add an explicit validation step after parsing.
//!
//! Example usage (pseudo):
//! ```rust
//! use telemetryx_common::types::{Event, EventPayload};
//! use chrono::Utc;
//! let e = Event {
//!   event_id: "id-1".to_string(),
//!   source: Some("mobile-sdk".to_string()),
//!   event_type: Some("click".to_string()),
//!   timestamp: Utc::now(),
//!   attributes: Default::default(),
//!   partition_key: None,
//!   payload: EventPayload::Json(serde_json::json!({"x":1})),
//! };
//! e.validate().unwrap();
//! ```

pub mod types {
    //! Domain-level types for events.
    //!
    //! This module intentionally exposes ergonomic types (owned Strings, chrono
    //! DateTime, HashMap, etc.) to make downstream code simple and expressive.
    //! Keep wire-format specifics (prost-generated types) out of this module.

    use bytes::Bytes;
    use chrono::{DateTime, Utc};
    use serde::{Deserialize, Serialize};
    use std::collections::HashMap;

    /// EventPayload represents the body of an event. There are two primary
    /// categories supported:
    ///
    /// - Json(serde_json::Value): Structured JSON payloads. Use this when
    ///   producers send semantic data (maps/objects) that the server may
    ///   inspect, validate, or enrich.
    ///
    /// - Binary(Bytes): Opaque binary payloads. "Opaque binary" means the
    ///   ingestion service treats the bytes as uninterpreted data (a blob).
    ///   This is useful when producers send already-serialized protobufs,
    ///   compressed payloads, or application-specific binary formats. Because
    ///   binary data may be embedded in JSON for diagnostics, the serializer
    ///   represents binary as base64-encoded strings when serializing to JSON.
    ///
    /// Choosing between Json and Binary:
    /// - Use Json for schema-first, inspectable events (easier to query and
    ///   transform).
    /// - Use Binary for high-throughput or pre-serialized payloads where the
    ///   ingestion pipeline forwards bytes without parsing.
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    #[serde(untagged)]
    pub enum EventPayload {
        Json(serde_json::Value),
        /// Binary payloads are serialized as base64 strings when producing
        /// JSON (this keeps logs and HTTP responses JSON-friendly).
        Binary(#[serde(with = "base64_bytes")] Bytes),
    }

    /// Event is the canonical domain representation of an incoming event.
    ///
    /// This struct is intended to be small and focused on fields that are
    /// commonly required by downstream systems: an identifier, timestamp,
    /// optional routing keys, attributes, and the payload itself.
    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
    pub struct Event {
        /// Uniquely identifies the event. This may be provided by the
        /// producer or generated by the ingestion service if missing.
        pub event_id: String,

        /// Optional source identifier, e.g. `mobile-sdk`, `serverless-producer`.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source: Option<String>,

        /// Logical event type, for example `click`, `purchase`, `heartbeat`.
        /// Optional to allow schemaless events.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub event_type: Option<String>,

        /// Event timestamp in UTC. We serialize/deserialize using seconds
        /// precision to keep things compact and interoperable with
        /// `google.protobuf.Timestamp`.
        #[serde(with = "chrono::serde::ts_seconds")] 
        pub timestamp: DateTime<Utc>,

        /// Free-form metadata that can be used for routing, filtering or
        /// enrichment. Keys and values are strings.
        #[serde(default, skip_serializing_if = "HashMap::is_empty")]
        pub attributes: HashMap<String, String>,

        /// Optional partition key that downstream systems can use to ensure
        /// ordered writes for the same key (e.g. partitioning in Kafka).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub partition_key: Option<String>,

        /// The actual payload for the event.
        pub payload: EventPayload,
    }

    // --------- small helpers & serde bytes base64 adapter ---------
    // The JSON representation of binary bytes is base64 to avoid producing
    // invalid JSON and to make debugging easier when events are shown in
    // logs or returned in HTTP responses.
    mod base64_bytes {
        use bytes::Bytes;
        use serde::{self, Deserialize, Deserializer, Serializer};
        use base64::Engine;

        /// Serialize `Bytes` as a base64 string.
        pub fn serialize<S>(b: &Bytes, s: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            // Use the standard base64 engine for readability and compatibility.
            let encoded = base64::engine::general_purpose::STANDARD.encode(b.as_ref());
            s.serialize_str(&encoded)
        }

        /// Deserialize a base64 string into `Bytes`.
        pub fn deserialize<'de, D>(d: D) -> Result<Bytes, D::Error>
        where
            D: Deserializer<'de>,
        {
            let s = String::deserialize(d)?;
            let decoded = base64::engine::general_purpose::STANDARD
                .decode(&s)
                .map_err(serde::de::Error::custom)?;
            Ok(Bytes::from(decoded))
        }
    }

    impl Event {
        /// Basic validation rules for an Event.
        ///
        /// Current checks:
        /// - `event_id` must be non-empty
        /// - `timestamp` must not be too far in the future (allows small clock
        ///   skew). This helps avoid accidental acceptance of mis-timestamped
        ///   events that could break windowing/aggregation downstream.
        ///
        /// Returns an `EventError` describing the problem if validation fails.
        pub fn validate(&self) -> Result<(), crate::errors::EventError> {
            if self.event_id.trim().is_empty() {
                return Err(crate::errors::EventError::MissingId);
            }
            // Allow small clock skew (5 minutes). If you expect producers with
            // large clock skew, increase or remove this check.
            let now = Utc::now();
            if self.timestamp > now + chrono::Duration::minutes(5) {
                return Err(crate::errors::EventError::TimestampInFuture);
            }
            Ok(())
        }
    }
}

/// Centralized error types used by `telemetryx-common`.
///
/// These errors are intentionally small and serializable-friendly. They
/// represent pre-processing / validation failures that ingestion handlers
/// should translate to appropriate HTTP/gRPC responses.
pub mod errors {
    use thiserror::Error;

    /// Errors produced during event validation and parsing.
    #[derive(Error, Debug)]
    pub enum EventError {
        /// The event is missing an identifier.
        #[error("missing event id")]
        MissingId,

        /// The event timestamp appears to be in the future beyond allowed skew.
        #[error("event timestamp is in the future")]
        TimestampInFuture,

        /// Generic payload parse error, contains a short message.
        #[error("payload parse error: {0}")]
        PayloadParse(String),
    }
}

#[cfg(test)]
mod tests {
    use super::types::{Event, EventPayload};
    use bytes::Bytes;
    use chrono::Utc;
    use serde_json::json;

    #[test]
    fn build_and_validate_json_event() {
        let e = Event {
            event_id: "id-1".to_string(),
            source: Some("src".to_string()),
            event_type: Some("click".to_string()),
            timestamp: Utc::now(),
            attributes: Default::default(),
            partition_key: None,
            payload: EventPayload::Json(json!({"k":"v"})),
        };
        assert!(e.validate().is_ok());
    }

    #[test]
    fn build_and_validate_binary_event() {
        let e = Event {
            event_id: "id-2".to_string(),
            source: None,
            event_type: None,
            timestamp: Utc::now(),
            attributes: Default::default(),
            partition_key: Some("pk".to_string()),
            payload: EventPayload::Binary(Bytes::from_static(b"hello")),
        };
        assert!(e.validate().is_ok());
    }
}
