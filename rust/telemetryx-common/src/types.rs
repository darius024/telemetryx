// types.rs - domain event types
//! Domain-level types for events.
//!
//! This module intentionally exposes ergonomic types (owned Strings, chrono
//! DateTime, HashMap, etc.) to make downstream code simple and expressive.
//! Keep wire-format specifics (prost-generated types) out of this module.

use bytes::Bytes;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// EventPayload represents the body of an event. There are two primary
/// categories supported:
///
/// - Json(serde_json::Value): Structured JSON payloads. Use this when
///   producers send semantic data (maps/objects) that the server may
///   inspect, validate, or enrich.
///
/// - Binary(Bytes): Opaque binary payloads. "Opaque binary" means the
///   ingestion service treats the bytes as uninterpreted data (a blob).
///   This is useful when producers send already-serialized protobufs,
///   compressed payloads, or application-specific binary formats. Because
///   binary data may be embedded in JSON for diagnostics, the serializer
///   represents binary as base64-encoded strings when serializing to JSON.
///
/// Choosing between Json and Binary:
/// - Use Json for schema-first, inspectable events (easier to query and
///   transform).
/// - Use Binary for high-throughput or pre-serialized payloads where the
///   ingestion pipeline forwards bytes without parsing.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventPayload {
    Json(serde_json::Value),
    /// Binary payloads are serialized as base64 strings when producing
    /// JSON (this keeps logs and HTTP responses JSON-friendly).
    Binary(#[serde(with = "crate::adapters::base64_bytes")] Bytes),
}

/// Event is the canonical domain representation of an incoming event.
///
/// This struct is intended to be small and focused on fields that are
/// commonly required by downstream systems: an identifier, timestamp,
/// optional routing keys, attributes, and the payload itself.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Event {
    /// Uniquely identifies the event. This may be provided by the
    /// producer or generated by the ingestion service if missing.
    pub event_id: String,

    /// Optional source identifier, e.g. `mobile-sdk`, `serverless-producer`.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<String>,

    /// Logical event type, for example `click`, `purchase`, `heartbeat`.
    /// Optional to allow schemaless events.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub event_type: Option<String>,

    /// Event timestamp in UTC. We serialize/deserialize using seconds
    /// precision to keep things compact and interoperable with
    /// `google.protobuf.Timestamp`.
    #[serde(with = "chrono::serde::ts_seconds")]
    pub timestamp: DateTime<Utc>,

    /// Free-form metadata that can be used for routing, filtering or
    /// enrichment. Keys and values are strings.
    #[serde(default, skip_serializing_if = "HashMap::is_empty")]
    pub attributes: HashMap<String, String>,

    /// Optional partition key that downstream systems can use to ensure
    /// ordered writes for the same key (e.g. partitioning in Kafka).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition_key: Option<String>,

    /// The actual payload for the event.
    pub payload: EventPayload,
}

impl Event {
    /// Basic validation rules for an Event.
    ///
    /// Current checks:
    /// - `event_id` must be non-empty
    /// - `timestamp` must not be too far in the future (allows small clock
    ///   skew). This helps avoid accidental acceptance of mis-timestamped
    ///   events that could break windowing/aggregation downstream.
    ///
    /// Returns an `EventError` describing the problem if validation fails.
    pub fn validate(&self) -> Result<(), crate::errors::EventError> {
        if self.event_id.trim().is_empty() {
            return Err(crate::errors::EventError::MissingId);
        }
        // Allow small clock skew (5 minutes). If you expect producers with
        // large clock skew, increase or remove this check.
        let now = Utc::now();
        if self.timestamp > now + chrono::Duration::minutes(5) {
            return Err(crate::errors::EventError::TimestampInFuture);
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::{Event, EventPayload};
    use bytes::Bytes;
    use chrono::Utc;
    use serde_json::json;

    #[test]
    fn build_and_validate_json_event() {
        let e = Event {
            event_id: "id-1".to_string(),
            source: Some("src".to_string()),
            event_type: Some("click".to_string()),
            timestamp: Utc::now(),
            attributes: Default::default(),
            partition_key: None,
            payload: EventPayload::Json(json!({"k":"v"})),
        };
        assert!(e.validate().is_ok());
    }

    #[test]
    fn build_and_validate_binary_event() {
        let e = Event {
            event_id: "id-2".to_string(),
            source: None,
            event_type: None,
            timestamp: Utc::now(),
            attributes: Default::default(),
            partition_key: Some("pk".to_string()),
            payload: EventPayload::Binary(Bytes::from_static(b"hello")),
        };
        assert!(e.validate().is_ok());
    }
}
